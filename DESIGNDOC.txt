			+--------------------+
			|        CS 140      |
			| PROJECT 1: THREADS |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

Nada Ayman <Nada96Ayman@gmail.com>
Youssef Ahmed <engyousefahmed@gmail.com>
Yousef Zook <email@domain.example>

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct sleep_elem		/* a struct for the sleeping thread that contains
{				     
  struct list_elem e;			-list_elem: to be put in the sleepers list
  struct thread * t;			-thread: Pointer on the sleeping thread struct.
  int64_t time_to_wake;			-time_to_wake: min time for the thread to sleep.
};				*/

static struct list sleepers;    // Global list of sleeping threads.


---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

- When the timer_sleep() is called, it checks if the number of ticks is > 0 , otherwise the funtion
returns immediatley. Then it creates a new sleep_elem and intializes its members
and adds it to the sleepers list, where the insertion is done in order. Finally it calls thread_block() to block the thread. 
This is done ensuring the interrupts are disabled to prevent the timer interrupt from modifying the sleepers list while 
another insertion is done.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

- The sleeping threads are put into the "sleepers list" in a non-decreasing order according to their time_to_wake.
This assures that the first thread to wake up is at the beginning of the list, thus the timre interrupt
handler doesn't have to iterate over the whole list each time; it stops at the first sleeping thread that
its waking time had not passed yet.


---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

- Since there's only one the thread running at a time, only this thread can call timer_sleep().
As this thread disables interrupt, no multiple threads can enter the timer_sleep() simultaneously.


>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

- By disabling interrupts, this prevents the timer interrupt handler from modifying the sleepers list while 
another insertion is done.


---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

- This design is simple and reliable, by disabling interrupts race conditions are avoided.
By maintaing the sleepers list ordered, the amount of time spent in the timer interrupt handlerthe is reduced.

- Another way to avoid race conditions in the sleepers list is to use locks.
if the current thread called timer_sleep() and its running in its critical section after acuiring the lock,
the timer interrupt would be able to interrupt the execution, causing many side effects:
- In case of priority scheduling, this'll unnecesseraly modifynig the priority of threads competing on the lock.
- The call to thread_block() may be delayed for a long time , while instead it should spend that time sleeping.

- Eventually, this design has less side effects, and  more reliable


			 PRIORITY SCHEDULING
			 ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread
  {
    tid_t tid;                          /* Thread identifier. */
    enum thread_status status;          /* Thread state. */
    char name[16];                      /* Name (for debugging purposes). */
    uint8_t *stack;                     /* Saved stack pointer. */
    int number_of_locks;                /* number of locks that the thread acquires */
    int priority;                       /* Priority. */
    struct list priority_list;          /* stack of past priorities inherited */
    struct thread ** obstacle_thread;   /* the obstacling thread that this thread is waiting for */
    struct list_elem allelem;           /* List element for all threads list. */

    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /* List element. */
    int nice;                           /* Niceness of a thread. */
    real recent_cpu;                    /* An estimate of the CPU time the thread has used recently. */

#ifdef USERPROG
    /* Owned by userprog/process.c. */
    uint32_t *pagedir;                  /* Page directory. */
#endif

    /* Owned by thread.c. */
    unsigned magic;                     /* Detects stack overflow. */
  };

Some Fields are added to the struct thread:
-int number_of_locks - struct list priority_list - struct thread ** obstacle_thread - 
 real recent_cpu - nice.


>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

struct list priority_list: a List - behaves as a stack - is used to track the priority donation.

	       holds		    waits on
	A(30) -------> | lock1 |  <+++++++++++ D(50)

			  ^
			  +
		waits on  +
			  +		       	   
   			  +    holds
			B(35) -------> | lock2 |

	      				 ^
					 +
			      waits on   +
					 +		       	   
		   			 +    holds	           
					C(40) -------> | lock3 |

1) Thread A with priority 30 aquires lock1.
2) Thread B with priority 35 aquires lock2 and waits on lock1
3) Thread B donates its priority(35) to A.
4) Thread C aquires lock3 and waits on lock2
5) Thread C donates priority 40 to B which donates 40 to A
6) Thread D is created with priority 50 and tries to aquire lock1
7) Thread D donates its priority to A.

thread A with priority 60 is run - D aquires lock1 - B with priority 40 aquires lock1 - 
after B releases lock2 it's back to it's original priority 35 and C aquires lock3.

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

Semaphores: on calling sema_up(), the thread with the highest priority in the waiters list of the semaphore is obtained  list_max(), then unblocked. Also priority donation guarantees that the thread with the 
highest priority gets to obtain the lock it aquires first.
Locks and Condition variables: they are implemented using semaphores, therefore they follow the same previous logic.

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

1) check if thread can aquire the lock.
2) if not and priority schedualing in used perform priority donation.
3) when manage to aquire the lock.
	-set lock holder
	-increment the number_of_threads held by the thread.
	-set the obstacle_thread = NULL (The thread its waiting for).

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

1) decrement the number_of_locks held by the thread.
2) set the lock holder to NULL
3) if priority schedualing is used, 
   restore the original priority of the thread before the priority donation
4) sema_up();

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?

A thread may change its priorty while being donated the priority from a higher priority thread or
returning to its original priority after releasing a lock.

Solution: 

---- RATIONALE ----

>> B7: Why did you choose this design? In what ways is it superior to
>> another design you considered?

Using the list provided as a stack was chosen over lots of other alternatives to
implement priority donation.

			  ADVANCED SCHEDULER
			  ==================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

would we copy the struct thread?

---- ALGORITHMS ----

>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each
>> has a recent_cpu value of 0.  Fill in the table below showing the
>> scheduling decision and the priority and recent_cpu values for each
>> thread after each given number of timer ticks:

timer  recent_cpu    priority   thread
ticks   A   B   C   A   B   C   to run
-----  --  --  --  --  --  --   ------
 0
 4
 8
12
16
20
24
28
32
36

>> C3: Did any ambiguities in the scheduler specification make values
>> in the table uncertain?  If so, what rule did you use to resolve
>> them?  Does this match the behavior of your scheduler?

>> C4: How is the way you divided the cost of scheduling between code
>> inside and outside interrupt context likely to affect performance?

---- RATIONALE ----

>> C5: Briefly critique your design, pointing out advantages and
>> disadvantages in your design choices.  If you were to have extra
>> time to work on this part of the project, how might you choose to
>> refine or improve your design?

>> C6: The assignment explains arithmetic for fixed-point math in
>> detail, but it leaves it open to you to implement it.  Why did you
>> decide to implement it the way you did?  If you created an
>> abstraction layer for fixed-point math, that is, an abstract data
>> type and/or a set of functions or macros to manipulate fixed-point
>> numbers, why did you do so?  If not, why not?

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?